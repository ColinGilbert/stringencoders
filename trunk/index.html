<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>B64FAST -- High Performance base64 Encode/Decoder</title>
<script type="text/javascript">
tagwords = ['php', 'apache', 'google'];
</script>
<!--#include virtual="/js/header.html" -->

<h1>B64FAST -- High Performance base64 Encoder/Decoder</h1>

<p>
This base64 encoder / decoder is designed for web applications and
easily has twice the performance over other implementations.  The code
compiles under C, C99, and C++.  The code is released under a BSD
license, but if that is too restrictive let me know, and we'll make a
deal.
</p>

<p>
NOTE: The encoder does not add line breaks at every 76 characters, nor
does the decoder accept whitespace.  This makes it unsuitable for many
applications.
</p>


<h2> Performance</h2>

<p>
The second best version I found is from Apache, in <a
href="http://apr.apache.org/">apr_util 0.97</a> (the latest as of
12/2005).
</p>

<table>
<tr><th>&nbsp;</th><th>Encode</th><th>Decode</th></tr>
<tr><th>AMD 64 (Opteron)</th><td>2.0x</td><td>4.3x</td></tr>
<tr><th>Intel x86-32 P4 Xeon</th><td>1.0</td><td>1.8x</td></tr>
<tr><th>PowerPC G5 2.0 Ghz</th><td>1.1x</td><td>2.8x</td></tr>
<tr><th>PowerPC G4 1.33 Ghz</th><td>1.7x</td><td>3.0x</td></tr>
<tr><th>Intel x86-64</th><td>??</td><td>??</td></tr>

</table>

<p>
When compared to other implementations it is even faster: 2-4x faster
than PHP/Jabber1;  5x faster encoding, 50x faster decoding compared to
libcurl.
</p>

<p>
The rankings remain the same under gcc 3.4.4, gcc 4.0.2, under -O3,
-O2, and -Os, and for very small and very large message sizes.
</p>

<p>Unfortunately I have no timings for Intel x86-64 or the newer Intel
architectures</p>

<h2>How to Install</h2>

<p>
It's the standard "./configure; make; make install" process.  A static
and shared library "libb64fast" and header "b64fast.h" will be
installed in the usual places.
</p>

<p>
"make test" will build a run a unit test and a performance test.
</p>

<h2>How to Use</h2>
<p>
For encoding, the destination string should be at least i*4/3 +4 bytes
or use b64_encode_size to get the right value (this version uses a few
bytes more than others).  It returns the length of the output string.
</p>
<pre>
int b64_encode(char* dest, const char* src, int len);

int b64_encode_size(int inputlen);
</pre>

<p>
For decoding, the input should contain a string of base 64 characters.
If the input string contains an invalid character, the function
returns -1.  Otherwise it returns the length of the output string.
(The Apache version stops after the first invalid character, this code
will return an error).
</p>

<pre> int b64_decode(char* dest, const char* src, int len); </pre>

<h2> Making base64 URL safe</h2>

<p> A common usage of base 64 encoding is to add binary data to a URL
-- however the standard base 64 alphabet is NOT url safe!  The "+" and
"/" characters have special meanings and the server or your
application will mangle them.  To fix this problem, you have to use
alternate characters</p>

<p>Unfortunately, there is no standard on what those alternate
characters should be.  I recommend the following replacements, but
there are many others available.  See the <a
href="http://en.wikipedia.org/wiki/Base64#URL_Applications">Wikipedia
entry</a> for other examples.
</p>

<table>
<tr><th>Original</th><th>Web Safe</th></tr>
<tr><td><code>+</code></td><td><code>-</code> (dash)</td></tr>
<tr><td><code>/</code></td><td><code>_</code> (underscore)</td></tr>
<tr><td><code>=</code></td><td><code>*</code></td></tr>
</table>

<p>
You can certainly do a post-processing step and make the substitution,
or you can modify the code directly.  Just edit the #defines marked at
the top of src/bgen.c and recompile ('make').
</p>

<h2>So what's the secret?</h2>

<p>
Who would have though the lowly base64 algorithm could be improved?
</p>

<h3> Go Parallel -- Don't use char </h3>

<p>
The Big Secret for decoding is to treat the input and output not as an
array of chars but as an array of unsigned 32-bit integers.  For
encoding we read three input characters as one integer, and write out
one integer that represents four base64 characters. For decoding we do
the reverse.  There is some tricky overlapping going on, but the net
result is 4x less iterations of the main loop.  Oddly this trick
doesn't work as well in the encoding step.
</p>

<h3>If you are going to use a table, use a table</h3>

<p>
Instead of "table[i] << 16" do "table16[i]" which precomputes the
shift.  You might have to generate another table or two, but you save
the cost doing the shift which is expensive on x86 machines.
</p>

<h3> Parallel Error Checking </h3>

<p> For decoding, validity of the input is done four characters at a
time.  Recall that four b64 characters gets mapped to three bytes, so
using integers, four b64 characters can have a maximum value of
0x00FFFFFF.  In the code, if the character is invalid, the table
returns a value higher than the maximum, and after all four characters
are processed the result will be greater than the maximum.  You'll
probably have to get out a paper and pencil and stare at the code to
see how this works.
</p>

<h3> Basic Stuff </h3>

<ul> 
<li> Use "static const" for data is that is read-only</li>

<li> Use the same types both in size, and signedness when doing
arithmetic.</li>

<li>
Copy the pointer instead of using casts.  Do this once "unsigned char*
ptr = str;", instead of doing this in a loop "(unsigned char) str[i]"
(for example).  While it looks it it should be the same, I've found
the compiler makes different code, and you don't want anything extra
involving casts in your tight loops.</li>

</ul>
<!--#include virtual="/js/footer.html" -->
</body>
</html>
